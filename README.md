# git-study
learn git branching 

***
## 1단계  
* commit : 커밋은 부모 파일과 다른 점을 스냅샷으로 저장하는 개념  
           커밋하고 나면 커밋 이전의 파일이 부모 파일이 되고 새로 생성된 파일은 자식 파일이 된다.  
* branch : 특정 커밋에 대한 참조  
           git branch [브랜치명] -> 브랜치 생성  
           git checkout [브랜치명] -> 해당 브랜치로 이동하는 명령어  
* merge : git의 합치기(merge)는 두 개의 부모(parent)를 가리키는 하나의 커밋을 만들어 냅니다.  
          git merge [브랜치명] -> 현재 브랜치와 해당하는 브랜치를 합친다.  
* rebase : 커밋들을 모아서 복사한 뒤, 다른 곳에 떨궈 놓는다.
           리베이스를 하면 커밋들의 흐름을 보기 좋게 한 줄로 만들 수 있다는 장점이 있습니다. 리베이스를 쓰면 저장소의 커밋 로그와 이력이 한결 깨끗해집니다.
***
## 2단계    
* git에서 여기저기 옮겨다니기!!  
  * HEAD : 체크아웃된 커밋 -> 현재 작업중인 커밋  
  * HEAD를 분리한다는 것은 HEAD를 브랜치 대신 커밋에 붙이는 것을 의미  
  * git log를 이용하려 커밋의 해시값을 보고 이동할 수 있는데 다 쓸 필요는 없고 적당히 구분할 수 있는 정도의 해시값만 넣어줘도 깃이 알아서 찾아 넣는다.  
  * 해시로만 구분하는 것이 아닌 상대 참조로도 구분이 가능하다  
    * 한 번에 한 커밋 위로 이동하는 ^ ex)git checkout bugFix^
    * 한 번에 여러 커밋 위로 이동하는 ~<num> ex) git checkout HEAD~2 (현재 커밋을 이동)  
   
  * 제가 상대 참조를 사용하는 가장 일반적인 방법은 브랜치를 옮길 때 입니다. -f 옵션을 이용해서 브랜치를 특정 커밋에 직접적으로 재지정 할 수 있습니다. 이런 식으로 말이죠:  
  * git branch -f main HEAD~3  
  * (강제로) main 브랜치를 HEAD에서 세번 뒤로 옮겼습니다.  
* git에서 작업 되돌리기!!  
  * git reset : 브랜치로 하여금 예전의 커밋을 가리키도록 이동시키는 방식 -> 히스토리를 고쳐 쓴다. -> 다른 사람이 작업하는 리모트 브랜치에서는 쓸 수 없다. ex) git reset HEAD~1  
  * git revert : 변경 내역을 이전 커밋과는 정반대의 내용으로 새로운 커밋을 생성 ex) git revert HEAD  

***
## 3단계
* 작업을 여기저기로 옮기기!!  
  * git cherry-pick <Commit1> <Commit2> <...> : 현재 위치(HEAD) 아래에 있는 일련의 커밋들에대한 복사본을 만들겠다는 것을 간단히 줄인 말  
  * 인터렉티브 리베이스 : rebase 명령어를 사용할 때 -i 옵션을 같이 사용한다는 것 ->  git은 리베이스의 목적지가 되는 곳 아래에 복사될 커밋들을 보여주는 UI를 띄울것 입니다.  
                                                                     각 커밋을 구분할 수 있는 각각의 해시들과 메시지도 보여줍니다.  
    * 적용할 커밋들의 순서를 UI를 통해 바꿀수 있습니다(여기서는 마우스 드래그앤 드롭으로 가능합니다.  
    * 원하지 않는 커밋들을 뺄 수 있습니다. 이것은 pick을 이용해 지정할 수 있습니다(여기서는 pick토글 버튼을 끄는것으로 가능합니다)  
    * 마지막으로, 커밋을 스쿼시(squash)할 수 있습니다. 불행히도 저희 레벨은 몇개의 논리적 문제들 때문에 지원을 하지 않습니다. 이거에 대해서는 넘어가겠습니다. 요약하자면 커밋을 합칠 수 있습니다  
    * ex) git rebase -i HEAD~4  
   
***
## 4단계  
* 딱 한 개의 커밋만 가져오기  
* git commit --amend 명령으로 커밋 내용을 정정합니다  
* -- Git 태그는 특정 커밋들을 브랜치로 참조하듯이 영구적인 "milestone(이정표)"으로 표시합니다.  
  * Git 태그는 커밋들이 추가적으로 생성되어도 절대 움직이지 않는다는 것입니다. 여러분은 태그를 "체크아웃"한 후에 그 태그에서 어떤 작업을 완료할 수 없습니다   
  * -- 태그는 커밋 트리에서 특정 지점을 표시하기위한 닻같은 역할을 합니다.  
  * ex) git tag (내용) (위치)  
* git에는 여러분이 가장 가까운 "닻(태그)"에 비해 상대적으로 어디에 위치해있는지 *describe(묘사)*해주는 명령어가 있습니다. 이 명령어는 git describe 입니다!  
  * git describe <ref> :<ref>에는 commit을 의미하는 그 어떤것이던 쓸 수 있습니다. 만약 ref를 특정 지어주지 않으면, git은 그냥 지금 체크아웃된곳을 사용합니다  
  * 명령어의 출력은 다음과 같은 형태로 나타납니다:  
  * <tag>_<numCommits>_g<hash>  
    * tag는 가장 가까운 부모 태그를 나타냅니다. numCommits은 그 태그가 몇 커밋 멀리있는지를 나타냅니다. <hash>는 묘사하고있는 커밋의 해시를 나타냅니다
    * 
